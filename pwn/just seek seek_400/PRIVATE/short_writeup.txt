The challenge opens an empty file `file.txt` and writes some random string to it. Next `flag.txt` is opened and its contents are written to `file.txt` 5-bytes after the end of file (`lseek(fd, 5, SEEK_END)`). There is a `read_flag` function which will read a file provided by the third argument to the function. It also takes in an offset and whence argument which are used by `lseek`. The trick is to call this `read_flag` function with the right set of arguments so that `lseek` brings back the position of the next `read` to the right position so that the contents of flag is read into a buffer. Specifically, one needs to call `read_flag(SEEK_SET, fd_1, 76)` i.e. `read_flag(0, 3, 0x4c)`, considering the file descriptor is `3`. 
There's a `gets()` function at the end of `main`. Using the buffer overflow in `gets()`, one can call the `read_flag` function with the right arguments. Contestants have to figure out the offsets (76) of the location of flag inside `file.txt.` Participants should have clear knowledge of the intricacies of `lseek()`, `read()` and `write()` system calls. They also have to find the offsets of ROP gadgets required for passing arguments to `read_flag` namely POP RDI, RSI and RBX gadgets. As the given binary is statically linked, there are plenty of gadgets. Note that, the binary is a 64-bit executable. So knowledge of 64-bit bof is necessary. 
The binary prints the runtime address of `main`. From that printed address, runtime addresses of `read_flag` function and ROP gadgets can be easily calculated by adding the required offsets. The necessary ROP chain then can be easily constructed to set the RDI, RSI and RDX registers with appropriate values and finally calling `read_flag`.